  **Модель Faster-RCNN**  
  При создании модели использовались материалы статьи https://habr.com/ru/post/579050/ с учетом того, что в проекте использовался собственный размеченный датасет. В статье также ссылаются на примеры использования готовой модели Faster-RCNN из библиотеки torchvision из **[официальной документации](https://pytorch.org/tutorials/intermediate/torchvision_tutorial.html)** и **[руководства](https://debuggercafe.com/road-pothole-detection-with-pytorch-faster-rcnn-resnet50/)**.  
  В связи с тем, что исходные фотографии имеют большие размеры (2592х1944 пикселя), перед подачей в модель фотографии были предварительно уменьшены в размерах до величины 480х320 пикселя с помощью функции *scale_image*, а также соответствующим образом преобразованы размеченные bounding box'es. Далее данные с названием изображений, классов и списки bounding box были преобразованы в DataFrame. Посмотреть размеченное изображение из dataframe можно с помощью функции *draw_img_with_box*.  
  Экземпляр класса *torch.utils.data.Dataset* по индексу изображения выдает на выходе изображение в формате torch.tensor и словарь target, в котором будет информация о искомом объекте: координаты рамки и класс. В конструктор класса передаются данные таблицы из DataFrame и путь до папки с изображениями.  
  Модель создается с помощью функции *create_model*. Так как модель будет детектировать только одну модель, то внутри функции переопредляется *box_predictor* с количеством выходов - 2 (нулевой класс - фон).  
   Вспомогательная функция применяется к бачам при итерации по *torch.utils.data.DataLoader* (Позволяет избегать ошибок c размерностями внутри бачей).  
   Деление датасета на тренировочную, тестовую и валидационную выборки производятся с помощью функции train_test_split из библиотеки sklearn с зафиксированным random_state.  
   Далее настраиваются параметры обучения: определяется устройство, на котором будет обучаться модель, создается модель с помощью *create_model*, выбирается оптимизатор, скорость обучения и настройка изменения скорости обучения. Далее данные оборачиваются в *torch.utils.data.DataLoader* с возможностью установки размер бача (см. *train_data_loader*, *val_data_loader*). Изображения перемешиваются из тренировочной выборки перед подачей в модель.  
   Функции для тренировки (train) и валидации модели (val), внутри которых все данные внутри бача переводятся на устройство, на котором будут производится расчеты. Затем полученные тензоры подаются в модель и получается словарь со значениями функций потерь. После чего считается их сумма с записью в переменную *running_loss* для отслеживания прогресса обучения. В конце каждой эпохи выводится среднее значение функций потерь. Функция валидации модели от функции тренировки отличается отсутствием расчета градиента при валидации.  
   При проведении обучения создаются два списка в которые сохраняются значения функций потерь после каждой эпохи на тренировке и валидации.  
   Анализ хода обучения показывает, что при обучении на 20 эпохах Loss падает, однако поведение функции потерь на валидационной выборке показывает, что функции все же начинает переобучаться и нужно поработать над настройкой модели.
   
   Добавить про метрики качества...
   
   Функцией *draw_predict* можно посмотреть хорошо ли обучилась модель (отображение предсказанных областей и фотографии).  
   Ноутбук **2_2_Faster_RCNN_blastospores_v2.ipynb** представлен в проекте в папке **part_2_model_training**, а также предварительные результаты обучения модели представлены в [ноутбуке в Google Colab](https://colab.research.google.com/drive/1zLgh1fKG5nWR_Tb4mZva-eh9QME1OJzz?usp=sharing).
   
   
